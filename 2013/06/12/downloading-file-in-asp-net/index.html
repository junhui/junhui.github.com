<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="my daily technical solution and learning notes."><title>基于asp.net的文件下载 | Junhuih Notes</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-71924500-1','auto');ga('send','pageview');    </script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">基于asp.net的文件下载</h1><a id="logo" href="/.">Junhuih Notes</a><p class="description">Web, Solution</p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">基于asp.net的文件下载</h1><div class="post-meta">2013-06-12 | <span class="categories">分类于<a href="/categories/net/"> .net</a></span></div><span data-disqus-identifier="2013/06/12/downloading-file-in-asp-net/" class="disqus-comment-count"></span><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#u80CC_u666F"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u57FA_u4E8EAsp-net_u7684_u65B9_u6848"><span class="toc-number">2.</span> <span class="toc-text">基于Asp.net的方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Response-Write/Response-BinaryWrite"><span class="toc-number">2.1.</span> <span class="toc-text">Response.Write/Response.BinaryWrite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Response-TransmitFile"><span class="toc-number">2.2.</span> <span class="toc-text">Response.TransmitFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u5C06_u5927_u6587_u4EF6_u5206_u4E3A_u5C0F_u5757_u4E0B_u8F7D"><span class="toc-number">2.3.</span> <span class="toc-text">将大文件分为小块下载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#u6587_u4EF6_u5206_u5757_u5E76_u652F_u6301_u65AD_u70B9_u7EED_u4F20"><span class="toc-number">2.4.</span> <span class="toc-text">文件分块并支持断点续传</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u5176_u5B83_u53EF_u80FD"><span class="toc-number">3.</span> <span class="toc-text">其它可能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u7ED3_u8BBA"><span class="toc-number">4.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#u9644_u5F55"><span class="toc-number">5.</span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#u5173_u4E8EHTTP_1-1_u7684_u4E24_u4E2A_u6807_u5934_u5143_u7D20Accept-Ranges_u548CEtags_u7684_u8BF4_u660E"><span class="toc-number">5.1.</span> <span class="toc-text">关于HTTP 1.1的两个标头元素Accept-Ranges和Etags的说明</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="u80CC_u666F"><a href="#u80CC_u666F" class="headerlink" title="背景"></a>背景</h2><p>在WEB程序中下载一个文件，最简单有效的办法就是直接给个链接到该文件的虚拟路径，把所有的问题交给浏览器和WEB服务器(IIS)去处理，但这种“良好”好的解决方案也会带来一些其它问题，譬如：无法在程序中控制下载权限，无法统计下载信息，无法将文件名更改为一个对客户良好的名字（事实上，为了避免服务器中文件名的重复，我们一般会分配给文件一个很长而又没有任何实际意义的名字，这不是客户端希望看到的，所以我们有必要在下载时重新为文件分配一个有意义的名字）。</p>
<h2 id="u57FA_u4E8EAsp-net_u7684_u65B9_u6848"><a href="#u57FA_u4E8EAsp-net_u7684_u65B9_u6848" class="headerlink" title="基于Asp.net的方案"></a>基于Asp.net的方案</h2><h3 id="Response-Write/Response-BinaryWrite"><a href="#Response-Write/Response-BinaryWrite" class="headerlink" title="Response.Write/Response.BinaryWrite"></a>Response.Write/Response.BinaryWrite</h3><p><code>WriteFile</code>和<code>BinaryWrite</code>出现得比较早，在获取文件的路径后，会试图将文件流全部读入内存，之后再发送回客户端。对于小文件和流量很小的网站，使用这个方法或许问题不大，但如果文件很大或者网站的流量很大，使用这个方法可以让 aspnet_wp.exe 进程意味终止，导致当前服务器下所有 asp.net 站点全部瘫痪，不仅如此，服务器的物理内存也会在瞬间被填满，导致其它程序运行失败或意外终止。<br>示例代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string filePath = Server.MapPath(&#34;test.rar &#34;);&#10;FileInfo fileInfo = new FileInfo(filePath);&#10;Response.Clear();&#10;Response.ClearContent();&#10;Response.ClearHeaders();&#10;Response.AddHeader(&#34;Content-Disposition&#34;, &#34;attachment;filename=&#34; + fileInfo.Name);&#10;Response.ContentType = &#34;application/octet-stream&#34;;&#10;Response.AddHeader(&#34;Content-Length&#34;, fileInfo.Length.ToString());&#10;Response.WriteFile(fileInfo.FullName);&#10;Response.Flush();&#10;Response.End();</span><br></pre></td></tr></table></figure></p>
<h3 id="Response-TransmitFile"><a href="#Response-TransmitFile" class="headerlink" title="Response.TransmitFile"></a>Response.TransmitFile</h3><p><code>TransmitFile</code>是为了弥补<code>WriteFile</code>和<code>BinaryWrite</code>的不足才出现的方法，比<code>WriteFile</code>和<code>BinaryWrite</code>更加的稳定强大，对大文件的支持也不错。但其也有不足之处，对断点续传的支持不行，一个大的文件如果一次性没有下载完成的话，就需要从头再来。<br>示例代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Response.ClearContent();&#10;Response.AddHeader(&#34;Content-Disposition&#34;, &#34;attachment; filename=&#34; + fileInfo.Name);&#10;Response.AddHeader(&#34;Content-Length&#34;, fileInfo.Length.ToString());&#10;Response.ContentType = &#34;application/octet-stream&#34;;&#10;Response.TransmitFile(fileInfo.FullName);&#10;Response.End();</span><br></pre></td></tr></table></figure></p>
<h3 id="u5C06_u5927_u6587_u4EF6_u5206_u4E3A_u5C0F_u5757_u4E0B_u8F7D"><a href="#u5C06_u5927_u6587_u4EF6_u5206_u4E3A_u5C0F_u5757_u4E0B_u8F7D" class="headerlink" title="将大文件分为小块下载"></a>将大文件分为小块下载</h3><p>每次使用 while 循环读取文件中的 10,000 个字节，然后将这些文件块发送给浏览器。因此，在运行时文件不会有任何重要部分保留在内存中。文件块大小目前被设为一个常量，但可通过编程方式对其修改，甚至也可以将其移动到配置文件中，以便根据服务器限制和性能要求对其进行更改。<br>示例代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Buffer to read 10K bytes in chunk:&#10;byte[] buffer = new Byte[10000];&#10;int length;&#10;long dataToRead;&#10;System.IO.Stream iStream = null;&#10;try&#10;&#123;&#10;&#9;// Open the file.&#10;&#9;iStream = new System.IO.FileStream(filepath, System.IO.FileMode.Open,&#10;&#9;System.IO.FileAccess.Read, System.IO.FileShare.Read);&#9;&#9;&#9;&#9;&#10;&#9;// Total bytes to read:&#10;&#9;dataToRead = iStream.Length;&#10;&#9;Response.ContentType = &#34;application/octet-stream&#34;;&#10;&#9;Response.AddHeader(&#34;Content-Disposition&#34;, &#34;attachment; filename=&#34; + filename);&#10;&#10;&#9;// Read the bytes.&#10;&#9;while (dataToRead &#62; 0) &#123;&#10;&#9;&#9;// Verify that the client is connected.&#10;&#9;&#9;if (Response.IsClientConnected) &#123;&#10;&#9;&#9;&#9;length = iStream.Read(buffer, 0, 10000);&#10;&#9;&#9;&#9;Response.OutputStream.Write(buffer, 0, length);&#10;&#9;&#9;&#9;Response.Flush();&#10;&#9;&#9;&#9;buffer = new Byte[10000];&#10;&#9;&#9;&#9;dataToRead = dataToRead - length;&#10;&#9;&#9;&#125;&#10;&#9;&#9;else &#123;&#10;&#9;&#9;&#9;//prevent infinite loop if user disconnects&#10;&#9;&#9;&#9;dataToRead = -1;&#10;&#9;&#9;&#125;&#10;&#9;&#125;&#10;&#125;&#10;catch (Exception ex) &#123;&#10;&#9;Response.Write(&#34;Error : &#34; + ex.Message);&#10;&#125;&#10;finally &#123;&#10;&#9;if (iStream != null) &#123;&#9;&#9;&#9;&#9;&#10;&#9;&#9;iStream.Close();&#10;&#9;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="u6587_u4EF6_u5206_u5757_u5E76_u652F_u6301_u65AD_u70B9_u7EED_u4F20"><a href="#u6587_u4EF6_u5206_u5757_u5E76_u652F_u6301_u65AD_u70B9_u7EED_u4F20" class="headerlink" title="文件分块并支持断点续传"></a>文件分块并支持断点续传</h3><p>结合将大文件分为小块下载和<code>HTTP 1.1</code>的两个标头元素<code>Accept-Ranges/Etags</code>实现对断点续传的支持。<br>为使 ASP.NET 下载应用程序实现可恢复下载功能，您需要能够拦截浏览器发出的请求（进行下载恢复），并使用请求中的 HTTP 标头在 ASP.NET 代码中明确表达相应的响应。要完成此操作，您应在正常处理序列中早一些捕获该请求。<br>示例代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// &#60;summary&#62;&#10;/// &#19979;&#36733;&#25991;&#20214;&#65292;&#25903;&#25345;&#22823;&#25991;&#20214;&#12289;&#32493;&#20256;&#12289;&#36895;&#24230;&#38480;&#21046;&#12290;&#25903;&#25345;&#32493;&#20256;&#30340;&#21709;&#24212;&#22836;Accept-Ranges&#12289;ETag&#65292;&#35831;&#27714;&#22836;Range &#12290;&#10;/// Accept-Ranges&#65306;&#21709;&#24212;&#22836;&#65292;&#21521;&#23458;&#25143;&#31471;&#25351;&#26126;&#65292;&#27492;&#36827;&#31243;&#25903;&#25345;&#21487;&#24674;&#22797;&#19979;&#36733;.&#23454;&#29616;&#21518;&#21488;&#26234;&#33021;&#20256;&#36755;&#26381;&#21153;&#65288;BITS&#65289;&#65292;&#20540;&#20026;&#65306;bytes&#65307;&#10;/// ETag&#65306;&#21709;&#24212;&#22836;&#65292;&#29992;&#20110;&#23545;&#23458;&#25143;&#31471;&#30340;&#21021;&#22987;&#65288;200&#65289;&#21709;&#24212;&#65292;&#20197;&#21450;&#26469;&#33258;&#23458;&#25143;&#31471;&#30340;&#24674;&#22797;&#35831;&#27714;&#65292;&#10;/// &#24517;&#39035;&#20026;&#27599;&#20010;&#25991;&#20214;&#25552;&#20379;&#19968;&#20010;&#21807;&#19968;&#30340;ETag&#20540;&#65288;&#21487;&#30001;&#25991;&#20214;&#21517;&#21644;&#25991;&#20214;&#26368;&#21518;&#34987;&#20462;&#25913;&#30340;&#26085;&#26399;&#32452;&#25104;&#65289;&#65292;&#36825;&#20351;&#23458;&#25143;&#31471;&#36719;&#20214;&#33021;&#22815;&#39564;&#35777;&#23427;&#20204;&#24050;&#32463;&#19979;&#36733;&#30340;&#23383;&#33410;&#22359;&#26159;&#21542;&#20173;&#28982;&#26159;&#26368;&#26032;&#30340;&#12290;&#10;/// Range&#65306;&#32493;&#20256;&#30340;&#36215;&#22987;&#20301;&#32622;&#65292;&#21363;&#24050;&#32463;&#19979;&#36733;&#21040;&#23458;&#25143;&#31471;&#30340;&#23383;&#33410;&#25968;&#65292;&#20540;&#22914;&#65306;bytes=1474560- &#12290;&#10;/// &#21478;&#22806;&#65306;UrlEncode&#32534;&#30721;&#21518;&#20250;&#25226;&#25991;&#20214;&#21517;&#20013;&#30340;&#31354;&#26684;&#36716;&#25442;&#20013;+&#65288;+&#36716;&#25442;&#20026;%2b&#65289;&#65292;&#20294;&#26159;&#27983;&#35272;&#22120;&#26159;&#19981;&#33021;&#29702;&#35299;&#21152;&#21495;&#20026;&#31354;&#26684;&#30340;&#65292;&#25152;&#20197;&#22312;&#27983;&#35272;&#22120;&#19979;&#36733;&#24471;&#21040;&#30340;&#25991;&#20214;&#65292;&#31354;&#26684;&#23601;&#21464;&#25104;&#20102;&#21152;&#21495;&#65307;&#10;/// &#35299;&#20915;&#21150;&#27861;&#65306;UrlEncode &#20043;&#21518;, &#23558; &#34;+&#34; &#26367;&#25442;&#25104; &#34;%20&#34;&#65292;&#22240;&#20026;&#27983;&#35272;&#22120;&#23558;%20&#36716;&#25442;&#20026;&#31354;&#26684;&#10;/// &#60;/summary&#62;&#10;/// &#60;param name=&#34;httpContext&#34;&#62;&#24403;&#21069;&#35831;&#27714;&#30340;HttpContext&#60;/param&#62;&#10;/// &#60;param name=&#34;filePath&#34;&#62;&#19979;&#36733;&#25991;&#20214;&#30340;&#29289;&#29702;&#36335;&#24452;&#65292;&#21547;&#36335;&#24452;&#12289;&#25991;&#20214;&#21517;&#60;/param&#62;&#10;/// &#60;param name=&#34;speed&#34;&#62;&#19979;&#36733;&#36895;&#24230;&#65306;&#27599;&#31186;&#20801;&#35768;&#19979;&#36733;&#30340;&#23383;&#33410;&#25968;&#60;/param&#62;&#10;/// &#60;returns&#62;true&#19979;&#36733;&#25104;&#21151;&#65292;false&#19979;&#36733;&#22833;&#36133;&#60;/returns&#62;&#10;public static bool DownloadFile(HttpContext httpContext, string filePath, long speed)&#10;&#123;&#10;&#9;httpContext.Response.Clear();&#10;&#9;bool ret = true;&#10;&#9;try&#10;&#9;&#123;&#10;&#9;&#9;#region --&#39564;&#35777;&#65306;HttpMethod&#65292;&#35831;&#27714;&#30340;&#25991;&#20214;&#26159;&#21542;&#23384;&#22312;#region&#10;&#9;&#9;switch (httpContext.Request.HttpMethod.ToUpper())&#10;&#9;&#9;&#123; //&#30446;&#21069;&#21482;&#25903;&#25345;GET&#21644;HEAD&#26041;&#27861;&#10;&#9;&#9;&#9;case &#34;GET&#34;:&#10;&#9;&#9;&#9;case &#34;HEAD&#34;:&#10;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;default:&#10;&#9;&#9;&#9;&#9;httpContext.Response.StatusCode = 501;&#10;&#9;&#9;&#9;&#9;return false;&#10;&#9;&#9;&#125;&#10;&#9;&#9;if (!File.Exists(filePath))&#10;&#9;&#9;&#123;&#10;&#9;&#9;&#9;httpContext.Response.StatusCode = 404;&#10;&#9;&#9;&#9;return false;&#10;&#9;&#9;&#125;&#10;&#9;&#9;#endregion&#10;&#10;&#9;&#9;#region &#23450;&#20041;&#23616;&#37096;&#21464;&#37327;#region &#23450;&#20041;&#23616;&#37096;&#21464;&#37327;&#10;&#9;&#9;long startBytes = 0;&#10;&#9;&#9;long stopBytes = 0;&#10;&#9;&#9;int packSize = 1024 * 10; //&#20998;&#22359;&#35835;&#21462;&#65292;&#27599;&#22359;10K bytes&#10;&#9;&#9;string fileName = Path.GetFileName(filePath);&#10;&#9;&#9;FileStream myFile = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);&#10;&#9;&#9;BinaryReader br = new BinaryReader(myFile);&#10;&#9;&#9;long fileLength = myFile.Length;&#10;&#10;&#9;&#9;int sleep = (int)Math.Ceiling(1000.0 * packSize / speed);//&#27627;&#31186;&#25968;&#65306;&#35835;&#21462;&#19979;&#19968;&#25968;&#25454;&#22359;&#30340;&#26102;&#38388;&#38388;&#38548;&#10;&#9;&#9;string lastUpdateTiemStr = File.GetLastWriteTimeUtc(filePath).ToString(&#34;r&#34;);&#10;&#9;&#9;string eTag = HttpUtility.UrlEncode(fileName, Encoding.UTF8) + lastUpdateTiemStr;//&#20415;&#20110;&#24674;&#22797;&#19979;&#36733;&#26102;&#25552;&#21462;&#35831;&#27714;&#22836;;&#10;&#9;&#9;#endregion&#10;&#10;&#9;&#9;#region --&#39564;&#35777;&#65306;&#25991;&#20214;&#26159;&#21542;&#22826;&#22823;&#65292;&#26159;&#21542;&#26159;&#32493;&#20256;&#65292;&#19988;&#22312;&#19978;&#27425;&#34987;&#35831;&#27714;&#30340;&#26085;&#26399;&#20043;&#21518;&#26159;&#21542;&#34987;&#20462;&#25913;&#36807;&#10;&#9;&#9;if (myFile.Length &#62; long.MaxValue)&#10;&#9;&#9;&#123;//-------&#25991;&#20214;&#22826;&#22823;&#20102;-------&#10;&#9;&#9;&#9;httpContext.Response.StatusCode = 413;//&#35831;&#27714;&#23454;&#20307;&#22826;&#22823;&#10;&#9;&#9;&#9;return false;&#10;&#9;&#9;&#125;&#10;&#10;&#9;&#9;if (httpContext.Request.Headers[&#34;If-Range&#34;] != null)//&#23545;&#24212;&#21709;&#24212;&#22836;ETag&#65306;&#25991;&#20214;&#21517;+&#25991;&#20214;&#26368;&#21518;&#20462;&#25913;&#26102;&#38388;&#10;&#9;&#9;&#123;&#10;&#9;&#9;&#9;//----------&#19978;&#27425;&#34987;&#35831;&#27714;&#30340;&#26085;&#26399;&#20043;&#21518;&#34987;&#20462;&#25913;&#36807;--------------&#10;&#9;&#9;&#9;if (httpContext.Request.Headers[&#34;If-Range&#34;].Replace(&#34;\&#34;&#34;, &#34;&#34;) != eTag)&#10;&#9;&#9;&#9;&#123;//&#25991;&#20214;&#20462;&#25913;&#36807;&#10;&#9;&#9;&#9;&#9;httpContext.Response.StatusCode = 412;//&#39044;&#22788;&#29702;&#22833;&#36133;&#10;&#9;&#9;&#9;&#9;return false;&#10;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#125;&#10;&#9;&#9;#endregion&#10;&#10;&#9;&#9;try&#10;&#9;&#9;&#123;&#10;&#9;&#9;&#9;#region -------&#28155;&#21152;&#37325;&#35201;&#21709;&#24212;&#22836;&#12289;&#35299;&#26512;&#35831;&#27714;&#22836;&#12289;&#30456;&#20851;&#39564;&#35777;&#10;&#9;&#9;&#9;httpContext.Response.Clear();&#10;&#10;&#9;&#9;&#9;if (httpContext.Request.Headers[&#34;Range&#34;] != null)&#10;&#9;&#9;&#9;&#123;//------&#22914;&#26524;&#26159;&#32493;&#20256;&#35831;&#27714;&#65292;&#21017;&#33719;&#21462;&#32493;&#20256;&#30340;&#36215;&#22987;&#20301;&#32622;&#65292;&#21363;&#24050;&#32463;&#19979;&#36733;&#21040;&#23458;&#25143;&#31471;&#30340;&#23383;&#33410;&#25968;------&#10;&#9;&#9;&#9;&#9;httpContext.Response.StatusCode = 206;//&#37325;&#35201;&#65306;&#32493;&#20256;&#24517;&#39035;&#65292;&#34920;&#31034;&#23616;&#37096;&#33539;&#22260;&#21709;&#24212;&#12290;&#21021;&#22987;&#19979;&#36733;&#26102;&#40664;&#35748;&#20026;200&#10;&#9;&#9;&#9;&#9;string[] range = httpContext.Request.Headers[&#34;Range&#34;].Split(new char[] &#123; &#39;=&#39;, &#39;-&#39; &#125;);//&#34;bytes=1474560-&#34;&#10;&#9;&#9;&#9;&#9;startBytes = Convert.ToInt64(range[1]);//&#24050;&#32463;&#19979;&#36733;&#30340;&#23383;&#33410;&#25968;&#65292;&#21363;&#26412;&#27425;&#19979;&#36733;&#30340;&#24320;&#22987;&#20301;&#32622;  &#10;&#9;&#9;&#9;&#9;if (startBytes &#60; 0 || startBytes &#62;= fileLength)&#10;&#9;&#9;&#9;&#9;&#123;&#10;&#9;&#9;&#9;&#9;&#9;//&#26080;&#25928;&#30340;&#36215;&#22987;&#20301;&#32622;&#10;&#9;&#9;&#9;&#9;&#9;return false;&#10;&#9;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#9;&#9;if (range.Length == 3)&#10;&#9;&#9;&#9;&#9;&#123;&#10;&#9;&#9;&#9;&#9;&#9;stopBytes = Convert.ToInt64(range[2]);//&#32467;&#26463;&#19979;&#36733;&#30340;&#23383;&#33410;&#25968;&#65292;&#21363;&#26412;&#27425;&#19979;&#36733;&#30340;&#32467;&#26463;&#20301;&#32622;  &#10;&#9;&#9;&#9;&#9;&#9;if (startBytes &#60; 0 || startBytes &#62;= fileLength)&#10;&#9;&#9;&#9;&#9;&#9;&#123;&#10;&#9;&#9;&#9;&#9;&#9;&#9;return false;&#10;&#9;&#9;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#9;&#125;&#10;&#10;&#9;&#9;&#9;httpContext.Response.Buffer = false;&#10;&#9;&#9;&#9;//httpContext.Response.AddHeader(&#34;Content-MD5&#34;, FileHash.MD5File(filePath));//&#29992;&#20110;&#39564;&#35777;&#25991;&#20214;&#10;&#9;&#9;&#9;httpContext.Response.AddHeader(&#34;Accept-Ranges&#34;, &#34;bytes&#34;);//&#37325;&#35201;&#65306;&#32493;&#20256;&#24517;&#39035;&#10;&#9;&#9;&#9;httpContext.Response.AppendHeader(&#34;ETag&#34;, &#34;\&#34;&#34; + eTag + &#34;\&#34;&#34;);//&#37325;&#35201;&#65306;&#32493;&#20256;&#24517;&#39035;&#10;&#9;&#9;&#9;httpContext.Response.AppendHeader(&#34;Last-Modified&#34;, lastUpdateTiemStr);//&#25226;&#26368;&#21518;&#20462;&#25913;&#26085;&#26399;&#20889;&#20837;&#21709;&#24212;                &#10;&#9;&#9;&#9;httpContext.Response.ContentType = &#34;application/octet-stream&#34;;//MIME&#31867;&#22411;&#65306;&#21305;&#37197;&#20219;&#24847;&#25991;&#20214;&#31867;&#22411;&#10;&#9;&#9;&#9;httpContext.Response.AddHeader(&#34;Content-Disposition&#34;, &#34;attachment;filename=&#34; + HttpUtility.UrlEncode(fileName, Encoding.UTF8).Replace(&#34;+&#34;, &#34;%20&#34;));&#10;&#9;&#9;&#9;httpContext.Response.AddHeader(&#34;Content-Length&#34;, (fileLength - startBytes).ToString());&#10;&#9;&#9;&#9;httpContext.Response.AddHeader(&#34;Connection&#34;, &#34;Keep-Alive&#34;);&#10;&#9;&#9;&#9;httpContext.Response.ContentEncoding = Encoding.UTF8;&#10;&#9;&#9;&#9;if (startBytes &#62; 0)&#10;&#9;&#9;&#9;&#123;//------&#22914;&#26524;&#26159;&#32493;&#20256;&#35831;&#27714;&#65292;&#21578;&#35785;&#23458;&#25143;&#31471;&#26412;&#27425;&#30340;&#24320;&#22987;&#23383;&#33410;&#25968;&#65292;&#24635;&#38271;&#24230;&#65292;&#20197;&#20415;&#23458;&#25143;&#31471;&#23558;&#32493;&#20256;&#25968;&#25454;&#36861;&#21152;&#21040;startBytes&#20301;&#32622;&#21518;----------&#10;&#9;&#9;&#9;&#9;httpContext.Response.AddHeader(&#34;Content-Range&#34;, string.Format(&#34;bytes &#123;0&#125;-&#123;1&#125;/&#123;2&#125;&#34;, startBytes, fileLength - 1, fileLength));&#10;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#9;#endregion&#10;&#10;&#9;&#9;&#9;#region -------&#21521;&#23458;&#25143;&#31471;&#21457;&#36865;&#25968;&#25454;&#22359;-------------------&#10;&#9;&#9;&#9;br.BaseStream.Seek(startBytes, SeekOrigin.Begin);&#10;&#9;&#9;&#9;int maxCount = (int)Math.Ceiling((fileLength - startBytes + 0.0) / packSize);//&#20998;&#22359;&#19979;&#36733;&#65292;&#21097;&#20313;&#37096;&#20998;&#21487;&#20998;&#25104;&#30340;&#22359;&#25968;&#10;&#9;&#9;&#9;for (int i = 0; i &#60; maxCount &#38;&#38; httpContext.Response.IsClientConnected; i++)&#10;&#9;&#9;&#9;&#123;//&#23458;&#25143;&#31471;&#20013;&#26029;&#36830;&#25509;&#65292;&#21017;&#26242;&#20572;&#10;&#9;&#9;&#9;&#9;httpContext.Response.BinaryWrite(br.ReadBytes(packSize));&#10;&#9;&#9;&#9;&#9;httpContext.Response.Flush();&#10;&#9;&#9;&#9;&#9;if (sleep &#62; 1) Thread.Sleep(sleep);&#10;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#9;#endregion&#10;&#9;&#9;&#125;&#10;&#9;&#9;catch&#10;&#9;&#9;&#123;&#10;&#9;&#9;&#9;ret = false;&#10;&#9;&#9;&#125;&#10;&#9;&#9;finally&#10;&#9;&#9;&#123;&#10;&#9;&#9;&#9;br.Close();&#10;&#9;&#9;&#9;myFile.Close();&#10;&#9;&#9;&#125;&#10;&#9;&#125;&#10;&#9;catch&#10;&#9;&#123;&#10;&#9;&#9;ret = false;&#10;&#9;&#125;&#10;&#9;return ret;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u5176_u5B83_u53EF_u80FD"><a href="#u5176_u5B83_u53EF_u80FD" class="headerlink" title="其它可能"></a>其它可能</h2><ul>
<li>使用FTP提供下载。可以利用FTP的特性进行权限控制。</li>
<li>扩展ISAPI以下载文件。</li>
</ul>
<h2 id="u7ED3_u8BBA"><a href="#u7ED3_u8BBA" class="headerlink" title="结论"></a>结论</h2><p>基于Asp.net下载的方式可以更灵活的对用户权限、下载统计进行扩展，下面是几个方案的简单对比：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Response.Write/BinaryWrite</code></td>
<td>代码简洁</td>
<td>大文件比较占用Server内存，可能把IIS托垮，不支持断点续传</td>
</tr>
<tr>
<td><code>Response.TransmitFile</code></td>
<td>代码简洁，大文件下载对服务器端资源占用较少</td>
<td>不支持断点续传</td>
</tr>
<tr>
<td>将大文件分为小文件</td>
<td>大文件下载对服务器端资源占用较少</td>
<td>不支持断点续传</td>
</tr>
<tr>
<td>文件分块并支持断点续传</td>
<td>支持断点续传</td>
<td>需要编码实现</td>
</tr>
</tbody>
</table>
<p>选择方案时，要根据可能需要支持的download文件大小以及用户的网络情况，做合理选择。如果需要支持的文件大小不是很大，可以直接使用<code>TransmitFile</code>进行下载，否则就要考虑支持断点续传。</p>
<h2 id="u9644_u5F55"><a href="#u9644_u5F55" class="headerlink" title="附录"></a>附录</h2><h3 id="u5173_u4E8EHTTP_1-1_u7684_u4E24_u4E2A_u6807_u5934_u5143_u7D20Accept-Ranges_u548CEtags_u7684_u8BF4_u660E"><a href="#u5173_u4E8EHTTP_1-1_u7684_u4E24_u4E2A_u6807_u5934_u5143_u7D20Accept-Ranges_u548CEtags_u7684_u8BF4_u660E" class="headerlink" title="关于HTTP 1.1的两个标头元素Accept-Ranges和Etags的说明"></a>关于HTTP 1.1的两个标头元素Accept-Ranges和Etags的说明</h3><p>Accept-Ranges 标头元素可以非常简单地向客户端（这里指 Web 浏览器）指明，此进程支持可恢复下载。实体标记或 Etag 元素将为该会话指定一个唯一标识符。因此，可由 ASP.NET 应用程序发送到浏览器以开始一个可恢复下载的 HTTP 标头可能如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK&#10;Connection: close&#10;Date: Mon, 22 May 2006 11:09:13 GMT&#10;Accept-Ranges: bytes&#10;Last-Modified: Mon, 22 May 2006 08:09:13 GMT&#10;ETag: &#34;58afcc3dae87d52:3173&#34;&#10;Cache-Control: private&#10;Content-Type: application/x-zip-compressed&#10;Content-Length: 39551221</span><br></pre></td></tr></table></figure></p>
<p>由于使用了 ETag 和 Accept-Headers，浏览器知道了 Web 服务器将支持可恢复下载。<br>如果下载失败，则当该文件再一次被请求时，Internet Explorer 将发送 ETag、文件名和指明在中断前已成功下载的文件字节数的值范围，以便 Web 服务器 (IIS) 可以尝试恢复下载。第二次请求可能如下所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET http://192.168.0.1/download.zip HTTP/1.0&#10;Range: bytes=933714-&#10;Unless-Modified-Since: Sun, 26 Sep 2004 15:52:45 GMT&#10;If-Range: &#34;58afcc3dae87d52:3173&#34;</span><br></pre></td></tr></table></figure></p>
<p>请注意，If-Range 元素包含服务器可用于标识要重新发送的文件的原始 ETag 值。您还会看到 Unless-Modified-Since 元素包含了最初下载的开始日期和时间。服务器将利用此信息来确定自最初下载开始后该文件是否已被修改过。如果已被修改，则服务器将从头开始重新下载。<br>Range 元素也包含在标头中，它会向服务器指明还需要传送多少字节才能完成文件，服务器可以利用此信息来确定应从已部分下载文件的何处开始继续下载。<br>不同浏览器使用这些标头的方式略有不同。客户端可能发送的用于唯一标识该文件的其他 HTTP 标头包括：If-Match、If-Unmodified-Since 和 Unless-Modified-Since。请注意，HTTP 1.1 在某个客户端应该需要支持哪些标头方面并没有特定要求。因此，就有可能出现这样的情况，某些 Web 浏览器不支持这些 HTTP 标头中的任一个，而其他浏览器可能使用不同于 IE 要求的标头的另一个标头。<br>默认情况下，IIS 将包含一个如下所示的标头集：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content&#10;Content-Range: bytes 933714-39551221/39551222&#10;Accept-Ranges: bytes&#10;Last-Modified: Sun, 26 Sep 2004 15:52:45 GMT&#10;ETag: &#34;58afcc3dae87d52:3173&#34;&#10;Cache-Control: private&#10;Content-Type: application/x-zip-compressed&#10;Content-Length: 2021408</span><br></pre></td></tr></table></figure></p>
<p>此标头集包含的响应代码不同于原始请求的响应代码。原始响应包含的代码为 200，而该请求使用的响应代码为 206（即“恢复下载”），用于向客户端指明，后面的数据不是一个完整文件，而只是继续先前启动的下载，该下载的文件名由 ETag 标识。<br>尽管某些 Web 浏览器依赖的是文件名其本身，但 Internet Explorer 非常明确地要求 ETag 标头。如果 ETag 标头在最初下载响应或下载恢复中不存在，则 Internet Explorer 不会尝试恢复下载，而只是开始一个新下载。</p>
</div><div class="tags"><a href="/tags/net/">.net</a><a href="/tags/asp-net/">asp.net</a></div><div class="post-nav"><a href="/2015/04/29/linux-command/" class="pre"><i class="icon-previous">Useful linux command</i></a></div><div id="disqus_thread"><script>var disqus_shortname = 'junhuih';
var disqus_identifier = '2013/06/12/downloading-file-in-asp-net/';
var disqus_title = '基于asp.net的文件下载';
var disqus_url = 'https://junhuih.com/2013/06/12/downloading-file-in-asp-net/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//junhuih.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="https://junhuih.com"/></form></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/net/">.net</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/bigdata/">bigdata</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/others/">others</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/https/" style="font-size: 15px;">https</a> <a href="/tags/varnish/" style="font-size: 15px;">varnish</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/httpclient/" style="font-size: 15px;">httpclient</a> <a href="/tags/bigdata/" style="font-size: 15px;">bigdata</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/dotnet/" style="font-size: 15px;">dotnet</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/node-js/" style="font-size: 15px;">node.js</a> <a href="/tags/d3-js/" style="font-size: 15px;">d3.js</a> <a href="/tags/magento/" style="font-size: 15px;">magento</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/security/" style="font-size: 15px;">security</a> <a href="/tags/hadoop/" style="font-size: 15px;">hadoop</a> <a href="/tags/sqoop/" style="font-size: 15px;">sqoop</a> <a href="/tags/spark/" style="font-size: 15px;">spark</a> <a href="/tags/others/" style="font-size: 15px;">others</a> <a href="/tags/net/" style="font-size: 15px;">.net</a> <a href="/tags/asp-net/" style="font-size: 15px;">asp.net</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/ehcache/" style="font-size: 15px;">ehcache</a> <a href="/tags/xss/" style="font-size: 15px;">xss</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/guava/" style="font-size: 15px;">guava</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/01/31/air-quality-index-for-america/">美国加州的空气到底怎么样</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/29/use-node-js-to-crawl-and-analysis-aqi-pm2-5-data/">抓取并分析近两年的空气质量数据(AQI/PM2.5)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/27/start-to-use-redis-cluster/">初步使用redis cluster集群</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/26/use-redis-bit-operation-to-do-realtime-metrics/">用redis的bit来快速实现用户信息统计</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/15/turn-website-from-http-to-https/">关于网站从http转到https</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/14/use-node-js-to-call-magento-api/">用node.js调用magento api</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/08/anti-xss-in-java-use-coverity-security-library/">anti-xss in java use coverity security library</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/06/use-redis-as-mybatis-cache-storage/">use redis as mybatis cache storage</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/05/custom-keygenerator-in-ehcache-with-spring/">custom keygenerator in ehcache with spring</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/04/Spring-Cacheable-annotation-with-google-guava-and-ehcache/">Spring @Cacheable annotation with google guava and ehcache</a></li></ul></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">Junhuih Notes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?8e4e20868ca997be7a75b457bd0ae31b";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></div></body></html>